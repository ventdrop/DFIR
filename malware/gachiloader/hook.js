// hook.js, to be used in conjunction with tracer.js developed by CheckPoint research
// Use this script to hook GachiLoader node malware variants if tracer.js does not succeed
// Usage: node -r tracer.js -r hook.js <scriptname>
const cp = require('child_process');
const { Readable, Writable } = require('stream');
const { EventEmitter } = require('events');
const Module = require('module');
const originalSpawn = cp.spawn;
const originalRequire = Module.prototype.require;

// Track loaded .node files
global.loadedNodeFiles = [];

// Hook require to monitor .node loading
Module.prototype.require = function(id) {
    if (id && (id.endsWith('.node') || id.includes('.node'))) {
        console.log('\n========================================');
        console.log('[!!!] .NODE FILE REQUIRE DETECTED [!!!]');
        console.log('========================================');
        console.log('Module:', id);
        console.log('Caller:', this.filename);
        console.log('========================================\n');
        
        global.loadedNodeFiles.push(id);
        
        // Try to load it but catch errors
        try {
            const loaded = originalRequire.apply(this, arguments);
            console.log('[SUCCESS] .node file loaded successfully');
            console.log('Exported functions:', Object.keys(loaded));
            return loaded;
        } catch (e) {
            console.log('[ERROR] Failed to load .node file:', e.message);
            
            // Return mock object to continue execution
            console.log('[MOCK] Returning fake .node module interface');
            return {
                init: function() { 
                    console.log('[MOCK] init() called'); 
                    return true; 
                },
                start: function() { 
                    console.log('[MOCK] start() called'); 
                    return true; 
                },
                connect: function(url) { 
                    console.log('[MOCK] connect() called with:', url); 
                    return true; 
                },
                send: function(data) { 
                    console.log('[MOCK] send() called with data length:', data?.length); 
                    return true; 
                },
                __esModule: true,
                default: function() { return true; }
            };
        }
    }
    
    return originalRequire.apply(this, arguments);
};

// Hook process.dlopen to see native loading
if (process.dlopen) {
    const originalDlopen = process.dlopen;
    process.dlopen = function(module, filename, flags) {
        console.log('\n========================================');
        console.log('[!!!] process.dlopen CALLED [!!!]');
        console.log('========================================');
        console.log('DLL Path:', filename);
        console.log('Module ID:', module.id);
        console.log('========================================\n');
        
        return originalDlopen.apply(this, arguments);
    };
}

// Tasklist hook (existing)
cp.spawn = function(command, args, options) {
    const fullCommand = command + ' ' + (args || []).join(' ');
    
    if (command === 'tasklist' || (command && command.includes('tasklist'))) {
        console.log('[HOOKED] tasklist');
        
        const fakeProcess = new EventEmitter();
        fakeProcess.stdout = new Readable({ read() {} });
        fakeProcess.stderr = new Readable({ read() {} });
        fakeProcess.stdin = new Writable({ write(chunk, encoding, callback) { callback(); } });
        fakeProcess.kill = () => true;
        fakeProcess.pid = 12345;
        
        setImmediate(() => {
            fakeProcess.stdout.push('"chrome.exe","3456","Console","1","234567 K"\r\n');
            fakeProcess.stdout.push(null);
            setTimeout(() => {
                fakeProcess.emit('close', 0, null);
                fakeProcess.emit('exit', 0, null);
            }, 50);
        });
        
        return fakeProcess;
    }
    
    // PowerShell hook (existing)
    if (command === 'powershell.exe' || command === 'powershell' || fullCommand.includes('powershell')) {
        console.log('[HOOKED] PowerShell');
        
        const fakeProcess = new EventEmitter();
        fakeProcess.stdout = new Readable({ read() {} });
        fakeProcess.stderr = new Readable({ read() {} });
        fakeProcess.stdin = new Writable({ write(chunk, encoding, callback) { callback(); } });
        fakeProcess.kill = () => true;
        fakeProcess.pid = 23456;
        
        setImmediate(() => {
            let fakeOutput = '';
            let decodedCmd = '';
            
            const argsStr = (args || []).join(' ');
            if (argsStr.includes('-EncodedCommand') || argsStr.includes('-enc')) {
                const base64Match = argsStr.match(/(?:-EncodedCommand|-enc)\s+([A-Za-z0-9+/=]+)/i);
                if (base64Match) {
                    try {
                        decodedCmd = Buffer.from(base64Match[1], 'base64').toString('utf16le');
                        console.log('  Decoded:', decodedCmd);
                    } catch(e) {}
                }
            }
            
            const cmdCheck = (decodedCmd || argsStr).toLowerCase();
            
            if (cmdCheck.includes('win32_portconnector') && cmdCheck.includes('count')) {
                fakeOutput = '12\r\n';
            } else if (cmdCheck.includes('win32_videocontroller') && cmdCheck.includes('name')) {
                fakeOutput = 'NVIDIA GeForce RTX 3060\r\n';
            } else if (cmdCheck.includes('win32_diskdrive') && cmdCheck.includes('model')) {
                fakeOutput = 'Samsung SSD 970 EVO Plus 1TB\r\n';
            } else {
                fakeOutput = '\r\n';
            }
            
            fakeProcess.stdout.push(fakeOutput);
            fakeProcess.stdout.push(null);
            
            setTimeout(() => {
                fakeProcess.emit('close', 0, null);
                fakeProcess.emit('exit', 0, null);
            }, 50);
        });
        
        return fakeProcess;
    }
    
    return originalSpawn.apply(this, arguments);
};

console.log('[HOOK] All hooks loaded - .node loading will be monitored\n');
