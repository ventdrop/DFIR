#!/usr/bin/env node
// capture_final_payload.js
// Usage: node capture_final_payload.js <hook_file> <malware_file> [--timeout <seconds>] [--outdir <directory>]
//
// Example: node capture_final_payload.js ./hook.js ./DNjFSUjpGTxnqNnC --timeout 180 --outdir ./output

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

// --- Argument Parsing ---
function printUsage() {
    console.log(`
Usage: node capture_final_payload.js <hook_file> <malware_file> [options]

Arguments:
  hook_file       Path to the hook/loader script (e.g. ./hook.js)
  malware_file    Path to the malware sample to detonate (e.g. ./DNjFSUjpGTxnqNnC)

Options:
  --timeout <s>   Monitoring duration in seconds (default: 120)
  --outdir <dir>  Directory to write captured payloads (default: cwd)
  -h, --help      Show this help message
`);
}

const args = process.argv.slice(2);

if (args.includes('-h') || args.includes('--help') || args.length < 2) {
    printUsage();
    process.exit(args.includes('-h') || args.includes('--help') ? 0 : 1);
}

const hookFile = args[0];
const malwareFile = args[1];

let timeout = 120;
let outdir = process.cwd();

for (let i = 2; i < args.length; i++) {
    if (args[i] === '--timeout' && args[i + 1]) {
        timeout = parseInt(args[i + 1], 10);
        if (isNaN(timeout) || timeout <= 0) {
            console.error('[ERROR] --timeout must be a positive integer (seconds)');
            process.exit(1);
        }
        i++;
    } else if (args[i] === '--outdir' && args[i + 1]) {
        outdir = args[i + 1];
        i++;
    } else {
        console.error(`[ERROR] Unknown option: ${args[i]}`);
        printUsage();
        process.exit(1);
    }
}

// Validate inputs exist
if (!fs.existsSync(hookFile)) {
    console.error(`[ERROR] Hook file not found: ${hookFile}`);
    process.exit(1);
}
if (!fs.existsSync(malwareFile)) {
    console.error(`[ERROR] Malware file not found: ${malwareFile}`);
    process.exit(1);
}

// Ensure output directory exists
if (!fs.existsSync(outdir)) {
    fs.mkdirSync(outdir, { recursive: true });
    console.log(`[INFO] Created output directory: ${outdir}`);
}

console.log('=== GachiLoader Payload Capture ===');
console.log(`  Hook file:    ${hookFile}`);
console.log(`  Malware file: ${malwareFile}`);
console.log(`  Output dir:   ${outdir}`);
console.log(`  Timeout:      ${timeout}s\n`);

// --- Hooks ---
let payloadCount = 0;

// Hook crypto.createDecipheriv
const originalCreateDecipheriv = crypto.createDecipheriv;
crypto.createDecipheriv = function (algorithm, key, iv) {
    const decipher = originalCreateDecipheriv.apply(this, arguments);
    const originalUpdate = decipher.update.bind(decipher);
    const originalFinal = decipher.final.bind(decipher);

    let chunks = [];

    decipher.update = function (data, inputEncoding, outputEncoding) {
        const result = originalUpdate(data, inputEncoding, outputEncoding);
        if (result) chunks.push(result);
        return result;
    };

    decipher.final = function (outputEncoding) {
        const result = originalFinal(outputEncoding);
        if (result) chunks.push(result);

        const fullPayload = Buffer.concat(chunks);
        const filename = `payload_${payloadCount}_${fullPayload.length}bytes.bin`;
        const filepath = path.join(outdir, filename);
        fs.writeFileSync(filepath, fullPayload);
        console.log(`\n[SAVED] ${filepath}`);
        console.log(`  Size: ${fullPayload.length} bytes`);
        console.log(`  Type: ${fullPayload.slice(0, 2).toString() === 'MZ' ? 'PE Executable' : 'Unknown'}`);

        payloadCount++;
        return result;
    };

    return decipher;
};

// Hook .node native addon loading
const Module = require('module');
const originalRequire = Module.prototype.require;
Module.prototype.require = function (id) {
    const loaded = originalRequire.apply(this, arguments);

    if (id && id.endsWith('.node')) {
        console.log('\n[HOOKING .NODE FUNCTIONS]');

        for (const key of Object.keys(loaded)) {
            const original = loaded[key];
            if (typeof original === 'function') {
                loaded[key] = function (...args) {
                    console.log(`\n[.NODE CALL] ${key}()`);

                    if (args[0] && Buffer.isBuffer(args[0])) {
                        console.log(`  Arg: Buffer(${args[0].length} bytes)`);
                        console.log(`  Starts with: ${args[0].slice(0, 32).toString('hex')}`);

                        const argFile = path.join(outdir, `node_input_arg_${args[0].length}.bin`);
                        fs.writeFileSync(argFile, args[0]);
                        console.log(`  [SAVED] ${argFile}`);
                    }

                    try {
                        const result = original.apply(this, args);
                        console.log(`  Result:`, typeof result, JSON.stringify(result)?.substring(0, 100));
                        return result;
                    } catch (e) {
                        console.log(`  [ERROR]`, e.message);
                        throw e;
                    }
                };
            }
        }
    }

    return loaded;
};

// --- Execute ---
require(path.resolve(hookFile));
require(path.resolve(malwareFile));

console.log(`\nMonitoring for ${timeout} seconds...`);
setTimeout(() => {
    console.log('\n=== EXECUTION COMPLETE ===');
    console.log(`Captured ${payloadCount} payload(s) in ${outdir}`);
    process.exit(0);
}, timeout * 1000);
